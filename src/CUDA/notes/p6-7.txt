CUDA中的全局内存指的是显存中的内存，可与CPU内存进行读写。

全局内存由于没有放在GPU的芯片上，因此具有较高的延迟和较低的访问速度。
然而它的容量是所有设备内存中最大的。其容量基本上就是显存容量。

静态全局内存变量由以下方式在任何函数外部定义：
__device__ T x = 0; // 单个变量
__device__ T y[N]; // 固定长度的数组

常量内存有标准的使用方法，即在核函数外面用 __constant__ 定义，
并用 CUDA 运行时 API 函数 cudaMemcpyToSymbol 
将数据从主机端复制到设备的常量内存后供核函数使用

对于计算能力大于等于 3.5 的 GPU 来说，将某些只读全局变量用 __ldg() 函数通过只
读数据缓存（read-only data cache）读取，既可达到使用纹理内存的加速效果，又让代码简
洁。该函数的原型为：
T __ldg(const T* address);

在核函数中定义的不加任何限定符的变量一般来说就存放于寄存器（register）。
如直接在核函数中定义 int i = 1

寄存器中放不下的变量，以及索引值不能在编译时就确定的数组，都有可能放在局部内存。
每个线程最多能使用高达 512 KB 的局部内存，但使用过多会降低程序性能。

不完整的线程束花的时间和完整的线程束花的时间一样，这就无形中浪费了计算资源。

在 CUDA 工具箱中，有一个名为 CUDA_Occupancy_Calculator.xls 的 Excel 文档，
可用来计算各种情况下的 SM 占有率

用编译器选项 --ptxas-options=-v 可以报道每个核函
数的寄存器使用数量。

CUDA 还提供了核函数的 __launch_bounds__() 修饰符
和 --maxrregcount= 编译选项来让用户分别对一个核函数和所有核函数中
寄存器的使用数量进行控制。

• 一个 SM 中最多能拥有的线程块个数为 Nb = 16（开普勒架构和图灵架构）或者 Nb =
32（麦克斯韦、帕斯卡和伏特架构）；
• 一个 SM 中最多能拥有的线程个数为 Nt = 2048（从开普勒架构到伏特架构）或者 Nt =
1024（图灵架构）。
blocksize设置时，应当服从Nt/Nb×2的倍数

L1在每个SM
L2在整个GPU
